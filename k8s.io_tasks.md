# The k8s.io tasks

There's some great tasks over at [k8s.io](https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/) where you get to test _a lot_ of different things in regards to Kubernetes. It's a really good way of getting to know Kubernetes step by step, you don't have to do them sequentially and it's perfectly fine to cherry-pick tasks you find interesting or that covers areas you are interested in.

Far from all tasks requires a configured multi master setup and with a external etcd cluster, minikube works just fine.

I'm keeping track of which tasks i've done in this file and i'll be using the cluster created provided from this repo.

## Tasks status

Status | Task |  Notes
--- | --- |  ---
:white_check_mark: |Â Customizing DNS Service | Within the kube-dns ConfigMap you can specify `upstreamNameserver`. `dnsPolicy` for Pods are default set to `None`. If you configure `ClusterFirst` the name resolution is handled differently.
:white_check_mark: | Assign Memory Resources to Containers and Pods | A container can _exceed_ its memory **request** if the Node has memory available. A container is _not allowed_ to use more than it's memory **limit**. If the container consume memory beyond it's limits the container is _terminated_. Reported status of a Pod can be e.g. `OOMKilled` (Out Of Memory).<br><br> Memory requests and limits are associated with _containers_ but it's useful to think o a Pod as having a memory request and limit. The memory _request_ are the sum of the memory requests for _all_ the containers in the Pod. Same goes for memory _limit_. <br><br> A Pod is scheduled to run on a Node only if the Node has _enough memory_ to satisfy the Pod's memory _request_. The status of the Pod would be `Pending` and a event would state that there's no available nodes to satisfy the specified resources.<br><br>If you don't specify a memory limit then the container has no _upper bound_ on the amount of memory it uses. A namespace can have a default memory limit set with the `LimitRange` within a namespace. Setting a higher _limit_ than _request_ leaves room for bursts of usage.
:white_check_mark: | Assign CPU Resources to Containers and Pods | The CPU resurce is measured in _cpu units_. One _cpu_ in Kubernetes are equivalent to e.g. 1 hyperthread on bare-metal Intel processor with Hyperthreading. A container that requests _0.5 cpu_ is guaranteed half as much CPU as a container that requests _1 cpu_. CPU is always requested as an absolute quantity, neever as a relative quantity. _0.5_ is the same amount on a single-core, dual-core or 48-core machine.<br><br>The concepts of CPU requests and limits are the same as for memory.
:white_check_mark: | Configure Quality of Service for Pods | K8s uses QoS classes to make decisions about scheduling and evicting Pods. There's three different QoS classes: _Guaranteed_, _Burstable_ and _BestEffort_. Remember that if you skip memory request and set a limit the request will be set to match the limit.<br><br>Guaranteed class are given to a Pod when every container have the same memory limit and request, the same goes with CPU.<br><br>Burstable are given if a Pod does not meet the criteria for Guaranteed and at least one container in the Pod has a memory or CPU request.<br><br>BestEffort class are given if the Pod doesn't have any memory or CPU limits/requests configured.
:white_check_mark: | Assign Extended Resources to a Container | You can request an extended resource (other than CPU and memory) and set limits and requests based on these. The extened resources are outside of  `*.kubernetes.io/`. They should have the form of `yourcompany.com/foo` where `foo` are a descriptive resource name.
:white_check_mark: | Advertise Extended Resources for a Node | To advertise a new extended resource on a Node you send a `PATCH /api/v1/nodes/<your-node-name>/status` request to the Kubernetes API server. You then specify in the JSON body that the path will be something like: `"path": "/status/capacity/example.com~1dongle"` and `"value": "4"`. `~1` are the encoding for the `/` character.
:black_square_button: | Configure a Pod to Use a Volume for Storage | -
:white_check_mark: | Configure Service Accounts for Pods | A service account provides an identity for processes that run in a Pod. Processes in containers inside Pods can contact the API server, when they do they are authenticated as a particular _Service Account_, for example `default`.<br><br>When you create a Pod and do not _specify_ a service account it is automatically assigned the `default` service account in the same namespace. You can check the service account by issuing this command `kubectl get pods POD_NAME -o jsonpath='{.spec.serviceAccount}'`.<br><br>You can easily create new service accounts, when you do this a new secret will be created. You may use authorization plugins to set permissions on services accounts. To use a non-default service account with a Pod, you can simply specify it by setting the `spec.serviceAccountName`. You could easily add a imagePullSecret to the `default` service account, then every new Pod created will have `imagePullSecret`added to their `spec`.

